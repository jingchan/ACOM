/**
 * ## Menu RenderObject
 * Renders a menu
 */

'use strict';

var Debug = require('../debug');
var PIXI = require('pixi.js');
var Phaser = require('phaser');
var RenderObject = require('./renderObject');
var util = require('util');

var exports = module.exports = MenuRenderObject;

/**
 * Constructor for Renderer object
 * @param {Scene} scene Scene to be rendered
 */
function MenuRenderObject(renderer, menu){
	RenderObject.call(this, renderer);

  var TS = renderer.tileSize;
  this.TS = TS;
  this.game = renderer.game;
  this.padding = [TS, 0.5*TS];

  this.fontObj = { font: '24px Arial', fill: '#fff' };
	this.menu = menu;
  this.index = 0;
  this.position = {x:menu.tilePosition.x*TS,
                   y:menu.tilePosition.y*TS};

	this.menuSize = [5*TS, this.padding[1]*2 + menu.items.length*TS];

	this.display = new PIXI.DisplayObjectContainer();

  // these are the things actually being displayed:
  // - [[ bkSprite ]] the background sprite (generated by dynamically-created texture [[texture]])
  // - [[ electionDisplay]] = the cursor (text)
  // - the item texts live in [[menuTexts]]

  this.texture = null;
  this.selectionDisplay = null;
  this.bkSprite = null;
  this.menuTexts = [];

	if(menu.type === 'hover_tile'){
 		this._generateHoverMenu();
  } else {
		throw new Error('Menu type not supported: ' + menu.type);
 	}


	this.state = 'hiding';

	// Register event listeners
	// TODO: implement cleanup/removal for these handlers
	var self = this;
	menu.on('selectionChanged', function(index){
    self.index = index;
    self.shouldRender = true;
	});

	menu.on('destroy', function(){
		self.renderer.removeRenderObject(self);
	});

  var that = this;
	menu.on('show', function(){
		self.state = 'showing';
    self.shouldRender = true;
		// self._repositionHoverMenu();

	});

	menu.on('hide', function(){
    // counterintuitive, but "shouldRender" is about "should the renderer care
    // now that you have changed?" (basically, it isn't about invisibility; the
    // only person that should shut it off is the render function
    self.shouldRender = true;
		self.state = 'hiding';
	});


}
util.inherits(MenuRenderObject, RenderObject);

exports.prototype.render = function() {

  if (this.state === 'hiding') {
    this.bkSprite.renderable = false;
    this.selectionDisplay.renderable = false;
    for (var i = 0; i < this.menuTexts.length; i++) {
      this.menuTexts[i].renderable = false;
    }
  } else if (this.state === 'showing') {
    this.bkSprite.renderable = true;
    this.selectionDisplay.renderable = true;
    for (var i = 0; i < this.menuTexts.length; i++) {
      this.menuTexts[i].renderable = true;
    }
    this.bkSprite.position.x = this.position.x;
    this.bkSprite.position.y = this.position.y;
    this.selectionDisplay.position.x = this.position.x + 0.5*this.TS;
    for (var i = 0; i < this.menuTexts.length; i++) {
      var gap = i*this.TS;
      this.menuTexts[i].position.x = this.position.x + this.TS;
      this.menuTexts[i].position.y = this.position.y + this.TS*0.5 + gap;
    }
    // TODO: change to reflect index
    if (this.menuTexts.length > 0) {
      this.selectionDisplay.position.y = this.menuTexts[this.index].position.y;
    } else {
      this.selectionDisplay.position.y = 0;
    }
  } else {
    Debug.log("should never get here...");
    console.log(this);
  }
  //console.log("should now be a selection at " + this.selectionDisplay.position.y);
};

// exports.prototype.initializeWithRenderer = function(renderer){
// 	this.renderer = renderer;
// 	this.reconstructMenu();
// };


exports.prototype._generateHoverMenu = function(){
  // TODO: be careful here about garbage collection!

  //console.log("let's make the actual menu!");
  //console.log(this);
  var game = this.game;
  var menu = this.menu;
  var TS = this.TS;

  this.display.removeChildren();

	// [[ Background ]]
	var backingDisplay = new PIXI.Graphics();
	backingDisplay.lineStyle(2, 0xffffff, 1);
	backingDisplay.beginFill(0x0000ff, 1);
	backingDisplay.drawRect(
		0,
		0,
		this.menuSize[0],
		this.menuSize[1]
	);
	this.display.addChild(backingDisplay);

  this.texture = new PIXI.RenderTexture(this.menuSize[0], this.menuSize[1]);
  this.texture.render(this.display);

  // these are the things actually being displayed:
  // - the background sprite
  // - the cursor (text)
  // - the item texts
  this.bkSprite = game.add.sprite(0,
                                  0,
                                  this.texture);

  this.selectionDisplay = game.add.text(0.5*TS, 0.5*TS, '>', this.fontObj);

  // generate all texts
  this.menuTexts = [];
  for (var i = 0; i < menu.items.length; i++) {
    var gap = i*TS;
    this.menuTexts.push(game.add.text(TS, 0.5*TS + gap, menu.items[i].text,
                                      this.fontObj));
  }

  // console.log("should have made stuff by now");
  // console.log(this);
	// this._repositionHoverMenu();
};

exports.prototype._repositionHoverMenu = function(){
	var renderer = this.renderer;
	var tilePosition = this.menu.tilePosition;
	var menuSize = [200, this.padding[1] * 2];

	// [[ Item List ]]
	var heightTravelled = 0;
	var padding = 10;

  if (this.items) {
	  this.items.forEach(function(text){
		  heightTravelled += text.height + padding;
	  });
  }

	// Adjust size of menu to accomodate items
	menuSize[1] += heightTravelled - padding;

	// Adjust position for overflows
	var menuOrigin = [(tilePosition[0] + 1) * renderer.tileSize, tilePosition[1] * renderer.tileSize];
	menuOrigin[0] = Math.max(menuOrigin[0], 0);
	menuOrigin[1] = Math.max(menuOrigin[1], 0);
	// Flip to left of cursor if horizontal overflow
	if(menuOrigin[0] > renderer.viewport[0] - menuSize[0]){
		menuOrigin[0] = menuOrigin[0] - menuSize[0] - renderer.tileSize;
	}
	// Cap bottom if vertical overflow
	menuOrigin[1] = Math.min(menuOrigin[1], renderer.viewport[1] - menuSize[1]);

	this.display.position.x = menuOrigin[0];
	this.display.position.y = menuOrigin[1];
  this.menuSize = menuSize;
};


exports.prototype.update = function(){
  // if (this.state === '') {
  //   return;
  // }
	// if(this.state === 'showing'){
  //   this.bkSprite.alpha = Math.min(this.bkSprite.alpha + 0.05, 1);
	// 	if(this.bkSprite.alpha >= 1){
	// 		this.state = '';
	// 	}
	// }	else if(this.state === 'hiding'){
	// 	this.bkSprite.alpha = Math.max(this.bkSprite.alpha - 0.05, 0);
	// 	if(this.bkSprite.alpha <= 0){
	// 		this.state = '';
	// 	}
	// }
  // this.shouldRender = true;
};
